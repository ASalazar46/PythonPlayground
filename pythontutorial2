# -----------
# while loops
# -----------
# while loops exist in python, dont use brackets for the body, use a ':' and indentations instead
a, b = 0, 1 # multiple declarations in a single line, assign a and b as 0 and 1, respectively
while a < 10:
    print(a, end=', ') # rather than make a newline after each print, we use end=', ' to put commas instead 
    a, b = b, a+b
print('\n')

# -------------
# if, elif, and else statements
# -------------
# if statements work the same way as in other languages, no brackets though
# and else if is shortened to elif
number = 10
if number > 10:
    print('number is greater than 10')
elif number == 10:
    print('number is 10')
elif number < 10:
    print('number is less than 10')
else: 
    print("What?")

# ---------
# for loops
# ---------
# Iterates over each item in the sequence in the order that they appear
# No need to define step and stop conditions
words = ['aaa', 'bbbbbbbbbb', 'ccccccccccccccccccccccccccccccccccccccccccccc']
for w in words:
    print(w, len(w))
# When working with a for loop that modifies the sequence it is iterating over, 
# it is better to loop over a copy or to make a new collection with the modified sequence

# ----------------
# range() function
# ----------------
# Generates arithmetic progressions
for i in range(5):
    print(i)
print('\n')
# range(n) gives a sequence of incrementing numbers, starting at 0 and ending before n

for i in range(5, 10):
    print(i)
print('\n')
# range(m, n) gives a sequence of incrementing numbers, starting at m and ending before n

for i in range(10, -10, -1):
    print(i)
print('\n')
# range(m, n, j) gives a sequence of numbers stepping by j, starting at m and ending before n 

# Can combine range() and len() to iterate over the indices of a sequence
a = ['what', 'the', 'flack']
for i in range(len(a)):
    print(i, a[i])
print('\n')
# enumerate() is more convenient, but that is for another time

# -------------------------------------------
# breaks and continues, else clauses in loops
# -------------------------------------------
# break clauses break out of the innermost loop that encloses it
# an else clause in a loop executes when:
#   a for loop has iterated through all item in the sequence
#   a while loop's condition becomes false
# does not execute when the loop is terminated by a break statement
for n in range(2, 10):
    for x in range(2, n):
        if n % x == 0:
            print(n, 'equals', x, '*', n//x)
            break
    else:
        # the above loop (second for loop) fell through to here 
        print(n, ' is a prime number')
print('\n')

# continue clauses continues with the next iteration of the loop 
for n in range(2, 10):
    if n % 2 == 0:
        print(n, ' is an even number')
        continue
    print(n, ' is an odd number')

# ---------------
# pass statements
# ---------------
# this statement does nothing. use when syntax is required, but no actions are needed
# useful for making stubs or empty functions and classes
for i in range(10):
    pass
def passedFunction(*args):
    pass
class Empty:
    pass

# -----------------
# match statements
# -----------------
# compares an expression to patterns given by case blocks
# think of it as a switch statement, but capable of taking the value's components
# and putting them into variables, does not use break statements
def ASDF(n):
    match n:
        case 1: 
            return "This is a 1"
        case 2: 
            return "This is a 2"
        case 3: 
            return "This is a 3"
        case 'a' | 'b' | 'c':
            return "This is either an a, b, or c"    
        case _:
            return "This is a default case, _. I always execute when no other cases match, if I am included as a case"
# If all cases fail, and no _ case is included, no branches are executed
# Can combine cases with a '|' operator
